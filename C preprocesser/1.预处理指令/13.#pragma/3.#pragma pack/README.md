# `#pragma pack`——用于指定内存对齐方式

### #pragma pack（[ show ] | [ push | pop ] [, identifier ] , n）

**指定结构、联合和类成员的封装对齐。其实就是改变编译器的内存对齐方式**。这个功能对于集合数据体使用，默认的数据的对齐方式占用内存比较大，可进行修改。

在没有参数的情况下调用pack会将n设置为编译器选项/zp中设置的值。**如果未设置编译器选项，windows默认为8，linux默认为4**。

具体的使用方法为，其中n的取值必须是2的幂次方，即1、2、4、8、16等：

```
1. #pragma pack(show)     以警告信息的形式显示当前字节对齐的值.
2. #pragma pack(n)        将当前字节对齐值设为 n .
3. #pragma pack()         将当前字节对齐值设为默认值(通常是4) .
4. #pragma pack(push)     将当前字节对齐值压入编译栈栈顶.
5. #pragma pack(pop)      将编译栈栈顶的字节对齐值弹出并设为当前值.
6. #pragma pack(push, n)  先将当前字节对齐值压入编译栈栈顶, 然后再将 n 设为当前值.
7. #pragma pack(pop, n)   将编译栈栈顶的字节对齐值弹出, 然后丢弃, 再将 n 设为当前值.

8. #pragma pack(push, identifier)        将当前字节对齐值压入编译栈栈顶, 然后将栈中保存该值的位置标识为 identifier .
10. #pragma pack(pop, identifier)        将编译栈栈中标识为 identifier 位置的值弹出, 并将其设为当前值. 注意, 如果栈中所标识的位置之上还有值, 那会先被弹出并丢弃.
11. #pragma pack(push, identifier, n)    将当前字节对齐值压入编译栈栈顶, 然后将栈中保存该值的位置标识为 identifier, 再将 n 设为当前值.
12. #pragma pack(pop, identifier, n)     将编译栈栈中标识为 identifier 位置的值弹出, 然后丢弃, 再将 n 设为当前值. 注意, 如果栈中所标识的位置之上还有值, 那会先被弹出并丢弃.
   
注意: 如果在栈中没有找到 pop 中的标识符, 则编译器忽略该指令, 而且不会弹出任何值.
```

使用时最好是成对出现的，要不容易引起错误，设置之后记得用完给恢复，如：

```
#pragma pack(n) 	//设置以n个字节为对齐长度
struct 
{
	int  ia；
 	char cb；
}
#pragma pack ()  	//弹出n个字节对齐长度，设置默认值为对齐长度
```

**如果想给单独一个结构体设置对齐长度还可以使用C++ 11 标准中的alignas。**

但是不是设置#pragma pack(n)就按照设置的字节进行对齐呢？其实并不是这样的，实际的对齐字节数要符合以下规则：
 **1、若设置了对齐长度n，实际对齐长度=Min（设置字节长度，结构体成员的最宽字节数)。若没有设置n，实际对齐长度 = Min（结构体成员的最宽字节数，默认对齐长度）。
 2、每个成员相对于首地址的偏移量（offset）都是实际对齐长度的整数倍，若不满足编译器进行填充。
 3、数据集合的总大小为实际对齐长度的整数倍，若不是编译器进行填充。**