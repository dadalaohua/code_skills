# 设计跳表

跳表这种数据结构是由 $\text{William Pugh}$ 发明的，关于跳表的详细介绍可以参考论文:「[Skip Lists: A Probabilistic Alternative to Balanced Trees](https://15721.courses.cs.cmu.edu/spring2018/papers/08-oltpindexes1/pugh-skiplists-cacm1990.pdf)」，论文中详细阐述了关于 $\texttt{skiplist}$ 查找元素、删除元素、插入元素的算法伪代码，以及时间复杂度的分析。跳表是一种随机化的数据结构，可以被看做二叉树的一个变种，它在性能上和红黑树、$\texttt{AVL}$ 树不相上下，但是跳表的原理非常简单，目前在 $\texttt{Redis}$ 和 $\texttt{LevelDB}$ 中都有用到。跳表的期望空间复杂度为 $O(n)$，跳表的查询，插入和删除操作的期望时间复杂度均为 $O(\log n)$。跳表实际为一种多层的有序链表，跳表的每一层都为一个有序链表，且满足每个位于第 $i$ 层的节点有 $p$ 的概率出现在第 $i+1$ 层，其中 $p$ 为常数。

它的结构类似于如下图所示:

跳表在进行查找时，首先从当前的最高层 $L(n)$ 层开始查找，在当前层水平地逐个比较直至当前节点的下一个节点大于等于目标节点，然后移动至下一层进行查找，重复这个过程直至到达第一层。此时，若下一个节点是目标节点，则成功查找；反之，则元素不存在。由于从高层往低层开始查找，由于低层出现的元素可能不会出现在高层，因此跳表在进行查找的过程中会跳过一些元素，相比于有序链表的查询，跳表的查询速度会更快。
跳表的初始化、查找、添加、删除操作详细描述如下：

![基本结构](.\1206_1.png)

- $\texttt{search}$：从跳表的当前的最大层数 $\textit{level}$ 层开始查找，在当前层水平地逐个比较直至当前节点的下一个节点大于等于目标节点，然后移动至下一层进行查找，重复这个过程直至到达第 $1$ 层。此时，若第 $1$ 层的下一个节点的值等于 $\textit{target}$，则返回 $\texttt{true}$；反之，则返回 $\texttt{false}$。如图所示：

![查询](.\1206_2.png)

- $\texttt{add}$：从跳表的当前的最大层数 $\textit{level}$ 层开始查找，在当前层水平地逐个比较直至当前节点的下一个节点大于等于目标节点，然后移动至下一层进行查找，重复这个过程直至到达第 $1$ 层。设新加入的节点为 $\textit{newNode}$，我们需要计算出此次节点插入的层数 $\textit{lv}$，如果 $\textit{level}$ 小于 $\textit{lv}$，则同时需要更新 $\textit{level}$。我们用数组 $\textit{update}$ 保存每一层查找的最后一个节点，第 $i$ 层最后的节点为 $\textit{update}[i]$。我们将 $\textit{newNode}$ 的后续节点指向 $update[i]$ 的下一个节点，同时更新 $update[i]$ 的后续节点为 $\textit{newNode}$ 。如图所示：

![添加1](.\1206_3.png)

![添加2](.\1206_4.png)

![添加3](.\1206_5.png)

![添加4](.\1206_6.png)

![添加5](.\1206_7.png)


- $\texttt{erase}$：首先我们需要查找当前元素是否存在跳表中。从跳表的当前的最大层数 $\textit{level}$ 层开始查找，在当前层水平地逐个比较直至当前节点的下一个节点大于等于目标节点，然后移动至下一层进行查找，重复这个过程直至到达第 $1$ 层。如果第 $1$ 层的下一个节点不等于 $\textit{num}$ 时，则表示当前元素不存在直接返回。我们用数组 $\textit{update}$ 保存每一层查找的最后一个节点，第 $i$ 层最后的节点为 $\textit{update}[i]$。此时第 $i$ 层的下一个节点的值为 $\textit{num}$，则我们需要将其从跳表中将其删除。由于第 $i$ 层的以 $p$ 的概率出现在第 $i+1$ 层，因此我们应当从第 $1$ 层开始往上进行更新，将 $\textit{num}$ 从 $update[i]$ 的下一跳中删除，同时更新 $update[i]$ 的后续节点，直到当前层的链表中没有出现 $\textit{num}$ 的节点为止。最后我们还需要更新跳表中当前的最大层数 $\textit{level}$。如图所示：

![删除1](.\1206_9.png)

![删除2](.\1206_10.png)

![删除3](.\1206_11.png)

![删除4](.\1206_12.png)

![删除5](.\1206_13.png)

![删除6](.\1206_14.png)

关于跳表的复杂度的分析如下：

- 空间复杂度分析：我们知道每次添加节点时，节点出现在第 $i$ 层的概率为 $(1-p)\times p^{i-1}$ ，跳表插入时的期望层数为:
  $\begin{aligned} E(L) &= 1 \times (1-p) + 2 \times (1-p)\times p + 3 \times (1-p) \times p^2 + \cdots \\ &= \sum_{i=1}^{\infty} i \times (1-p) \times p^{i-1} \\ &= (1-p) \times \sum_{i=1}^{\infty} i \times p^{i-1} \\ &= (1-p) \times \dfrac{1}{(1-p)^2} \\ &= \dfrac{1}{1-p} \end{aligned}$

如果节点的目标层数为 $L$，则此时需要的空间为 $O(L)$，因此总的空间复杂度为 $O(n \times E(L)) = O(n \times \dfrac{1}{1-p}) = O(n)$。

- 时间复杂度分析: 在含有 $n$ 个节点的跳表中，当前最大层数 $L(n)$ 包含的元素个数期望为 $\dfrac{1}{p}$ ，根据跳表的定义可以知道第 $1$ 层的每个元素出现在 $L(n)$ 的概率为 $p^{L(n)-1}
  $ ，则此时我们可以推出如下：
  $\begin{aligned} \dfrac{1}{p} &= np^{L(n)-1} \\ p^{L(n)} &= \dfrac{1}{n} \\ L(n) &= \log_p {\dfrac{1}{n}} \end{aligned}$

根据以上结论可以知道在含有 $n$ 个节点的跳表中，当前最大层数期望 $L(n) = \log_p {\dfrac{1}{n}}$ 。

我们首先思考一下搜索目标节点 $x$ 的过程，每次我们搜索第 $i$ 层时，如果第 $i$ 层的当前节点小于 $x$ 时，则我们会在第 $i$ 层向右进行搜索，直到下一个节点的值大于等于 $x$；如果第 $i$ 层的节点值大于等于 $x$，则我们则会下降到 $i-1$ 层。根据之前的定义，如果节点 $x$ 在第 $i$ 层出现，则节点 $x$ 一定会出现在第 $i-1$ 层。现在假设我们从 $L(n)$ 的第一个节点搜索到第 $1$ 层的目标节点 $x$ 的路径为 $S$，现在我们将路径 $S$ 反过来，即从第 $1$ 的节点 $x$ 回到 $L(n)$ 层的第一个节点，我们可以观察到从第 $1$ 层的节点 $x$ 一直往上一层，直到 $x$ 的最大层数，然后再向左走一步到达节点 $y$，再向上走，再重复上述步骤，实际搜索时如果在上一层可以到访问到节点 $x$，则在下一层遍历时一定不会访问所有小于 $x$ 的节点。假设当前我们处于一个第 $i$ 层的节点 $x$，此时并不知道 $x$ 的最大层数和 $x$ 左侧节点的最大层数，只知道 $x$ 的最大层数至少为 $i$。我们可以知道 $x$ 的最大层数大于 $i$，那么下一步按照最优选择应该是向上一层，这种情况的概率为 $p$；如果 $x$ 的最大层数等于 $i$，那么下一步应该是同一层向左侧后退一个节点，这种情况概率为 $1-p$。令 $C(i)$ 为在一个无限长度的跳表中向上爬 $i$ 层的期望代价，则知道:

$\begin{aligned} C(0) &= 0 \\ C(i) &= (1-p)(1 + C(i)) + p(1 + C(i-1)) \\ C(i) &= \dfrac{1}{p} + C(i-1) \\ C(i) &= \dfrac{i}{p} \end{aligned}$

在含有 $n$ 个元素的跳表中，从第 $1$ 层爬到第 $L(n)$ 层的期望步数存在上界 $\dfrac{L(n) - 1}{p}$ 。现在只需要分析爬到第 $L(n)$ 层后还要再走多少步。当达到第 $L(n)$ 层后，我们需要向左走。我们已知 $L(n)$ 层的节点总数的期望存在上界为 $\dfrac{1}{p}$ 。所以我们知道搜索的总的代价为:

$\dfrac{L(n) - 1}{p} + \dfrac{1}{p} = \dfrac{\log_{\frac{1}{p}}n -1}{p} + \dfrac{1}{p} = \dfrac{\log_{\frac{1}{p}}n}{p}$

根据以上推理可以得到查询的平均时间复杂度为 $O(\log n)$。

上述的推理过程与原本的论文相比还是有所忽略细节，如果对复杂度分析的详细细节感兴趣的可以参考原始论文:「[Skip Lists: A Probabilistic Alternative to Balanced Trees](https://15721.courses.cs.cmu.edu/spring2018/papers/08-oltpindexes1/pugh-skiplists-cacm1990.pdf)」。

作者：LeetCode-Solution
链接：https://leetcode.cn/problems/design-skiplist/solution/she-ji-tiao-biao-by-leetcode-solution-e8yh/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。