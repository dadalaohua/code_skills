构建位数组(bit array)

位向量，其实就是位数组（bit array），本质就是一个由位构成的序列。如果在C++/JAVA当中，这根本算不上一个问题，因为它们已经提供bitset（位集）这样现成的工具。而在C语言中却没有这样的工具，而且C语言对内存的管理都是以字节（byte）为单位的，从它提供的最小数据类型char来看，它都是占用一个字节，我们并没有一种直接操作位（bit）的数据类型？那么用一个数组，比如char bitarr[]来模拟行不行呢，它的每一个数组元素就对应一个位？当然是可以的，都是这并不是一种好的设计方案，我们知道一个char通常是一个字节，而一个字节又等于8个位。如果我们用一个char来模拟一个位的话，意味着会有7个位被浪费，而布隆过滤器通常是应用在大数据的情形下，这样一来就很不划算了。那么有没有办法把一个char的所有位都利用起来呢？
虽然C语言没有提供面向位的数据类型，但它也提供了丰富的位运算符，这使得我们有了访问一个char中某些位的能力，我在bitarray的实现中，在底层虽然我也是把char数组作为储存位（bit）的容器，但是我不是用一个char来代表一个位，而是把一个char的8个位全部能用上，这不仅更符合“位数组”的概念也大大提高了空间效率。
在具体实现之前先稍微讲一下要用到的基础的知识： 
如何访问一个整型变量中的某个特定的位？ 
这个问题需要用到C语言提供的几个位运算符：～（按位取反）、&（按位与）、|（按位或）、<<（左移）、>>（右移）。这些运算符的性质是基础知识就不赘述。这里还需要用到掩码技术。举个例子， 
char i=1;如果要把i的第5位变为1的话，就需要构造一个第5位为1，其他位均为0的掩码，然后把这个掩码与i进行“按位或”的运算在把运算结果赋给i。这样做是因为“按位或”运算，只用当两个操作数有一个为1时，其结果就为1，这样一来就可以发现，一个第5位为1其他位为0的掩码与i进行“按位或”时，就可以保证结果的第5位会被置为1，而结果的其他位不变。可能怎么说比较抽象，下面具体演示一下：

char i = 1;
//这时i的位模式是00000001
//构建一个第5位为1，其他位为0的掩码，它的位模式应该是：00100000
//注意位是从0开始计数的
char mask=0x20;//0x20是十六进制，等于00100000
i |= mask;
//过程如下：
/**
**i:        0000 0001
**        |
**mask:    0010 0000
**  ——————————————————————
**          0010 0001
**/

那么如何来构造一个特定位为1其他位为0的掩码呢？ 
使用<<运算符就行了：1 << j，j就是要置为1的位。 
这里有一个惯用法：

将第j位置位1：
i |= 1<<j;
这里要考虑一下数据类型的问题

同样的也有将第j位置为0的惯用法：

i &= ~(1<<j);

还有获取第j位状态的惯用法：
if(i & 1<<j)
{
  //某位不为0的处理
}
else
{
 //某位为0的处理
}

按照上面的思路应该都很好理解，这里不赘述。
有了上面基础知识的准备那么就很好实现这个数据结构了，由于我想要的是一个可以复用、易于维护的位数组（bit array），所以我把它设计成抽象数据结构，把实现和接口分离开来，并且采用C语言提供的“不完整类型”把实现的细节（主要是真正的bitarray数据结构）隐藏起来，仅提供一个指针（bit_array），这样就能最大限度的防止外部去访问和改变内部数据，避免了外部行为影响内部逻辑的风险。对位数组的一切访问都要通过我对外提供的接口。由于C语言没有提供足够多的用于“隐藏控制”（访问权限控制）和抽象的语言特性，所以相比JAVA来说，要实现这一点要难得多
