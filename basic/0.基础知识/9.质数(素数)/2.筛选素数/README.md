质数又称素数。一个大于1的自然数，除了1和它自身外，不能被其他自然数整除的数叫做质数；否则称为合数。
0和1既不是质数也不是合数，最小的质数是2

一般的方法虽然这样已经很快了，但仍然不是最优的，尤其是当我们需要寻找大量素数的时候，仍会消耗大量的时间。那么有没有什么办法可以批量查找素数呢？
有，这个方法叫做埃拉托斯特尼算法。这个名字念起来非常拗口，这是一个古希腊的名字。此人是个古希腊的大牛，是大名鼎鼎的阿基米德的好友。他虽然没有阿基米德那么出名，但是也非常非常厉害，在数学、天文学、地理学、文学、历史学等多个领域都有建树。并且还自创方法测量了地球直径、地月距离、地日距离以及黄赤交角等诸多数值。要知道他生活的年代是两千五百多年前，那时候中国还是春秋战国时期，可以想见此人有多厉害。
埃式筛法

我们今天要介绍的埃拉托斯特尼算法就是他发明的用来筛选素数的方法，为了方便我们一般简称为埃式筛法或者筛法。埃式筛法的思路非常简单，就是用已经筛选出来的素数去过滤所有能够被它整除的数。这些素数就像是筛子一样去过滤自然数，最后被筛剩下的数自然就是不能被前面素数整除的数，根据素数的定义，这些剩下的数也是素数。
举个例子，比如我们要筛选出100以内的所有素数，我们知道2是最小的素数，我们先用2可以筛掉所有的偶数。然后往后遍历到3，3是被2筛剩下的第一个数，也是素数，我们再用3去筛除所有能被3整除的数。筛完之后我们继续往后遍历，第一个遇到的数是7，所以7也是素数，我们再重复以上的过程，直到遍历结束为止。结束的时候，我们就获得了100以内的所有素数。

我们来分析一下筛法的复杂度，从代码当中我们可以看到，我们一共有了两层循环，最外面一层循环固定是遍历n次。而里面的这一层循环遍历的次数一直在变化，并且它的运算次数和素数的大小相关，看起来似乎不太方便计算。实际上是可以的，根据素数分布定理以及一系列复杂的运算（相信我，你们不会感兴趣的），我们是可以得出筛法的复杂度是O(n ln ln n)。


极致优化 

欧拉筛（线性筛）

筛法的复杂度已经非常近似O(n)了，因为即使在n很大的时候，经过两次ln的计算，也非常近似常数了，实际上在绝大多数使用场景当中，上面的算法已经足够应用了。
但是仍然有大牛不知满足，继续对算法做出了优化，将其优化到了O(n)的复杂度。虽然从效率上来看并没有数量级的提升，但是应用到的思想非常巧妙，值得我们学习。在我们理解这个优化之前，先来看看之前的筛法还有什么可以优化的地方。比较明显地可以看出来，对于一个合数而言，它可能会被多个素数筛去。比如38，它有2和19这两个素因数，那么它就会被置为两次False，这就带来了额外的开销，如果对于每一个合数我们只更新一次，那么是不是就能优化到O(n)了呢？
怎么样保证每个合数只被更新一次呢？这里要用到一个定理，就是每个合数分解质因数只有的结果是唯一的。既然是唯一的，那么一定可以找到最小的质因数，如果我们能够保证一个合数只会被它最小的质因数更新为False，那么整个优化就完成了。
那我们具体怎么做呢？其实也不难，我们假设整数n的最小质因数是m，那么我们用小于m的素数i乘上n可以得到一个合数。我们将这个合数消除，对于这个合数而言，i一定是它最小的质因数。因为它等于i * n，n最小的质因数是m，i 又小于m，所以i是它最小的质因数，我们用这样的方法来生成消除的合数，这样来保证每个合数只会被它最小的质因数消除。