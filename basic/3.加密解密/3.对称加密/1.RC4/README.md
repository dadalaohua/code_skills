RC4算法介绍
     RC4加密算法Ron Rivest(非常有名的非对称加密算法RSA三巨头之一)在1987年设计的，密钥长度可变的流加密算法簇。之所以称其为簇，是由于其核心部分的S-box长度可为任意，但一般为256字节。该算法的速度可以达到DES加密的10倍左右，且具有很高级别的非线性。RC4起初是用于保护商业机密的。但是在1994年9月，它的算法被发布在互联网上，也就不再有什么商业机密了。RC4也被叫做ARC4（Alleged RC4——所谓的RC4），因为RSA从来就没有正式发布过这个算法。
 备注：RC4是对称密钥加密算法，而RSA是非对称的加密算法。由于RC4算法加密是采用的xor，所以，一旦子密钥序列出现了重复，密文就有可能被破解。那么，RC4算法生成的子密钥序列是否会出现重复呢？由于存在部分弱密钥，使得子密钥序列在不到100万字节内就发生了完全的重复，如果是部分重复，则可能在不到10万字节内就能发生重复，因此，推荐在使用RC4算法时，必须对加密密钥进行测试，判断其是否为弱密钥。根据目前的分析结果，没有任何的分析对于密钥长度达到128位的RC4有效，所以，RC4是目前最安全的加密算法之一。

1、先初始化状态向量S（256个字节，用来作为密钥流生成的种子1）
按照升序，给每个字节赋值0,1,2,3,4,5,6.....,254,255
2、初始密钥（由用户输入），长度任意
如果输入长度小于256个字节，则进行轮转，直到填满
例如输入密钥的是1,2,3,4,5   ,  那么填入的是1,2,3,4,5,1,2,3,4,5,1,2,3,4,5........
由上述轮转过程得到256个字节的向量T（用来作为密钥流生成的种子2）
3、开始对状态向量S进行置换操作（用来打乱初始种子1）
按照下列规则进行
从第零个字节开始，执行256次，保证每个字节都得到处理
　j = 0;
　　for (i = 0 ; i < 256 ; i++){
　　　　j = (j + S[i] + T[i]) mod 256;
　　　　swap(S[i] , S[j]);
　　}
这样处理后的状态向量S几乎是带有一定的随机性了
4、最后是秘钥流的生成与加密，很多人在这里不是特别理解，别的博客也没有写的很简洁明了
假设我的明文字节数是datalength=1024个字节（当然可以是任意个字节）
i=0;
j=0;
while(datalength--){//相当于执行1024次，这样生成的秘钥流也是1024个字节
　　　i = (i + 1) mod 256;
　　　　j = (j + S[i]) mod 256;
　　　　swap(S[i] , S[j]);
　　　　t = (S[i] + S[j]) mod 256;
　　　　k = S[t];这里的K就是当前生成的一个秘钥流中的一位
　　　　//可以直接在这里进行加密，当然也可以将密钥流保存在数组中，最后进行异或就ok
　　　　data[]=data[]^k； //进行加密，"^"是异或运算符
}
解密按照前面写的，异或两次就是原文，所以只要把密钥流重新拿过来异或一次就能得到原文了
这样就完成了一次生成密钥流及加密的过程，这也是RC4的全部工作